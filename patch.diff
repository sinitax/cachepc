diff --git a/arch/x86/kvm/Makefile b/arch/x86/kvm/Makefile
index b804444e16d4..c94f8c4460f1 100644
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@ -10,7 +10,9 @@ endif
 KVM := ../../../virt/kvm
 
 kvm-y			+= $(KVM)/kvm_main.o $(KVM)/coalesced_mmio.o \
-				$(KVM)/eventfd.o $(KVM)/irqchip.o $(KVM)/vfio.o
+				$(KVM)/eventfd.o $(KVM)/irqchip.o $(KVM)/vfio.o \
+				svm/cachepc/cachepc.o svm/cachepc/util.o
+
 kvm-$(CONFIG_KVM_ASYNC_PF)	+= $(KVM)/async_pf.o
 
 kvm-y			+= x86.o emulate.o i8259.o irq.o lapic.o \
@@ -20,7 +22,8 @@ kvm-y			+= x86.o emulate.o i8259.o irq.o lapic.o \
 
 kvm-intel-y		+= vmx/vmx.o vmx/vmenter.o vmx/pmu_intel.o vmx/vmcs12.o \
 			   vmx/evmcs.o vmx/nested.o vmx/posted_intr.o
-kvm-amd-y		+= svm/svm.o svm/vmenter.o svm/pmu.o svm/nested.o svm/avic.o svm/sev.o
+kvm-amd-y		+= svm/svm.o svm/vmenter.o svm/pmu.o svm/nested.o svm/avic.o svm/sev.o \
+			   svm/cachepc/cachepc.o svm/cachepc/util.o
 
 obj-$(CONFIG_KVM)	+= kvm.o
 obj-$(CONFIG_KVM_INTEL)	+= kvm-intel.o
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 7b3cfbe8f7e3..71697d08e9e4 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -2,6 +2,8 @@
 
 #include <linux/kvm_host.h>
 
+#include "cachepc/cachepc.h"
+
 #include "irq.h"
 #include "mmu.h"
 #include "kvm_cache_regs.h"
@@ -3785,8 +3787,18 @@ static noinstr void svm_vcpu_enter_exit(struct kvm_vcpu *vcpu,
 
 static __no_kcsan fastpath_t svm_vcpu_run(struct kvm_vcpu *vcpu)
 {
-	struct vcpu_svm *svm = to_svm(vcpu);
+	static struct cache_ctx *ctx = NULL;
+	static struct cacheline *ds = NULL;
+	static struct cacheline *head = NULL;
+	static int run_index = 0;
+	struct vcpu_svm *svm;
+
+	printk(KERN_WARNING "CachePC: svm_cpu_enter_exit()\n");
+
+	if (!ctx) ctx = cachepc_get_ctx(L1);
+	if (!ds) ds = cachepc_prepare_ds(ctx);
 
+	svm = to_svm(vcpu);
 	svm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];
 	svm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];
 	svm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];
@@ -3835,8 +3847,14 @@ static __no_kcsan fastpath_t svm_vcpu_run(struct kvm_vcpu *vcpu)
 	 */
 	x86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);
 
+	head = cachepc_prime(ds);
+
 	svm_vcpu_enter_exit(vcpu, svm);
 
+	cachepc_probe(head);
+	//cachepc_print_msrmts(head);
+	cachepc_save_msrmts(head);
+
 	/*
 	 * We do not use IBRS in the kernel. If this vCPU has used the
 	 * SPEC_CTRL MSR it may have left it on; save the value and
@@ -3912,6 +3930,8 @@ static __no_kcsan fastpath_t svm_vcpu_run(struct kvm_vcpu *vcpu)
 	if (is_guest_mode(vcpu))
 		return EXIT_FASTPATH_NONE;
 
+	run_index += 1;
+
 	return svm_exit_handlers_fastpath(vcpu);
 }
 
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 2541a17ff1c4..c219a214d904 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -51,6 +51,9 @@
 #include <linux/io.h>
 #include <linux/lockdep.h>
 #include <linux/kthread.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
 
 #include <asm/processor.h>
 #include <asm/ioctl.h>
@@ -66,6 +69,8 @@
 /* Worst case buffer size needed for holding an integer. */
 #define ITOA_MAX_LEN 12
 
+#include "../../arch/x86/kvm/svm/cachepc/cachepc.h"
+
 MODULE_AUTHOR("Qumranet");
 MODULE_LICENSE("GPL");
 
@@ -143,6 +148,13 @@ static void hardware_disable_all(void);
 
 static void kvm_io_bus_destroy(struct kvm_io_bus *bus);
 
+uint8_t *cachepc_msrmts;
+size_t cachepc_msrmts_count;
+struct proc_ops cachepc_proc_ops;
+
+EXPORT_SYMBOL(cachepc_msrmts);
+EXPORT_SYMBOL(cachepc_msrmts_count);
+
 __visible bool kvm_rebooting;
 EXPORT_SYMBOL_GPL(kvm_rebooting);
 
@@ -4765,6 +4777,50 @@ static void check_processor_compat(void *data)
 	*c->ret = kvm_arch_check_processor_compat(c->opaque);
 }
 
+int
+kvm_cachepc_open(struct inode *inode, struct file *file)
+{
+	try_module_get(THIS_MODULE);
+
+	return 0;
+}
+
+int
+kvm_cachepc_close(struct inode *inode, struct file *file)
+{
+	module_put(THIS_MODULE);
+
+	return 0;
+}
+
+ssize_t
+kvm_cachepc_read(struct file *file, char *buf, size_t buflen, loff_t *off)
+{
+	size_t len, left;
+
+	printk(KERN_WARNING "CacheSC: Reading entries (%lu:%lli)\n",
+		buflen, off ? *off : 0);
+
+	if (!off || *off >= cachepc_msrmts_count || *off < 0)
+		return 0;
+
+	len = cachepc_msrmts_count - *off;
+	if (len > buflen) len = buflen;
+
+	left = copy_to_user(buf, cachepc_msrmts + *off, len);
+
+	len -= left;
+	*off += len;
+
+	return len;
+}
+
+ssize_t
+kvm_cachepc_write(struct file *file, const char *buf, size_t buflen, loff_t *off)
+{
+	return 0;
+}
+
 int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
 		  struct module *module)
 {
@@ -4848,6 +4904,20 @@ int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
 	r = kvm_vfio_ops_init();
 	WARN_ON(r);
 
+	cachepc_init_counters();
+
+	cachepc_msrmts_count = L1_SETS;
+	cachepc_msrmts = kzalloc(cachepc_msrmts_count, GFP_KERNEL);
+	BUG_ON(cachepc_msrmts == NULL);
+
+	memset(&cachepc_proc_ops, 0, sizeof(cachepc_proc_ops));
+	cachepc_proc_ops.proc_open = kvm_cachepc_open;
+	cachepc_proc_ops.proc_read = kvm_cachepc_read;
+	cachepc_proc_ops.proc_write = kvm_cachepc_write;
+	cachepc_proc_ops.proc_release = kvm_cachepc_close;
+
+	proc_create("cachepc", 0644, NULL, &cachepc_proc_ops);
+	
 	return 0;
 
 out_unreg:
@@ -4872,6 +4942,9 @@ EXPORT_SYMBOL_GPL(kvm_init);
 
 void kvm_exit(void)
 {
+	remove_proc_entry("cachepc", NULL);
+	kfree(cachepc_msrmts);
+
 	debugfs_remove_recursive(kvm_debugfs_dir);
 	misc_deregister(&kvm_dev);
 	kmem_cache_destroy(kvm_vcpu_cache);
